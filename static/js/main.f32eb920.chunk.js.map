{"version":3,"sources":["EventComponent.js","App.js","serviceWorker.js","index.js"],"names":["EventComponent","props","_onTouchStart","bind","_onTouchMove","_onTouchEnd","state","swiped","_swipe","minDistance","e","touch","touches","length","this","setState","x","clientX","y","clientY","changedTouches","swiping","absX","Math","abs","absY","onSwiped","onSwipedRight","onSwipedLeft","onTap","onTouchStart","onTouchMove","onTouchEnd","children","React","Component","pad","val","s","String","pages","App","index","useRef","useSprings","i","window","innerWidth","sc","display","set","api_root","useGesture","down","xDelta","delta","xDir","direction","distance","cancel","current","clamp","comic_name","useState","comics_json","setComicsJson","comics_labels","setComicsLabels","chapter_nr","setChapterNr","chapter_name","setChapterName","page_nr","setPageNr","source_arr","setSourceArr","hq_enabled","setHasHQ","preload_images","setSwiped","is_drawer_open","setIsDrawerOpen","current_label","setCurrentLabel","useEffect","fetchComics","getComicImages","new_chapter","count","Image","src","encodeURI","label","hq","getComicsLabels","json","labels","Object","entries","forEach","chapter","title","value","changeChapter","a","comics_json_LOCAL","fetch","response","console","error","setPage","data","nr","log","new_chapter_nr","new_page_nr","nextPage","prevPage","handlers","useSwipeable","warn","preventDefaultTouchmoveEvent","trackMouse","open","onChange","list","placeholder","renderItem","key","onClick","sideMargin","id","tapOrClick","event","type","alert","scrollTo","alt","showLoader","animationDuration","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.f32eb920.chunk.js","sourcesContent":["import React from 'react';\n\nexport default class EventComponent extends React.Component {\n\n  constructor(props) {\n    super(props);\n\n    this._onTouchStart = this._onTouchStart.bind(this);\n    this._onTouchMove = this._onTouchMove.bind(this);\n    this._onTouchEnd = this._onTouchEnd.bind(this);\n\n    this.state = { swiped: false };\n    this._swipe = {};\n    this.minDistance = 50;\n  }\n\n  _onTouchStart(e) {\n    const touch = e.touches[0];\n\t// If multiple touches? Ignore ?\n\tif (e.touches.length > 1) {\n\t\tthis._swipe = {}\n\t\tthis.setState({ swiped: false })\n\t\treturn\n\t}\n    this._swipe = { x: touch.clientX, y: touch.clientY };\n    this.setState({ swiped: false });\n  }\n\n  _onTouchMove(e) {\n    if (e.changedTouches && e.changedTouches.length) {\n      const touch = e.changedTouches[0];\n      this._swipe.swiping = true;\n    }\n  }\n\n  _onTouchEnd(e) {\n    const touch = e.changedTouches[0];\n\n    if( !this._swipe.swiping) {\n\t    this.props.onTap && this.props.onTap(touch)\n\t    return\n    }\n    const absX = Math.abs(touch.clientX - this._swipe.x);\n    const absY = Math.abs(touch.clientY - this._swipe.y);\n    // Don't swip if AbY is too high\n    if(this._swipe.swiping && absY > 80) {\n\tthis._swipe = {}\n\treturn\n\t}\n\n    if (this._swipe.swiping && absX > this.minDistance ) {\n      this.props.onSwiped(true);\n      this.setState({ swiped: true });\n      if(touch.clientX < this._swipe.x) {\n\t      // Swipe Right\n\t\tthis.props.onSwipedRight && this.props.onSwipedRight();\n      }\n      if(touch.clientX > this._swipe.x) {\n\t      // Swipe Left\n\t\tthis.props.onSwipedLeft && this.props.onSwipedLeft();\n\n      }\n    }\n    this._swipe = {};\n  }\n\n  render() {\n    return (\n      <div\n        onTouchStart={this._onTouchStart}\n        onTouchMove={this._onTouchMove}\n        onTouchEnd={this._onTouchEnd}>\n        { false ? `Component-${this.state.swiped ? 'swiped' : ''}` : null}\n\t{this.props.children}\n      </div>\n    );\n  }\n\n}\n","import { render } from 'react-dom'\nimport React, { useEffect, useState, useRef} from 'react';\nimport { hot } from 'react-hot-loader';\nimport Img from 'react-image'\nimport ReactImageAppear from 'react-image-appear'\nimport './App.css';\n\n//import axios from 'axios'\nimport Dropdown from 'react-dropdown'\nimport 'react-dropdown/style.css'\nimport Select from 'react-select'\n\n//import { Swipeable, defineSwipe } from 'react-touch'\n\nimport clamp from 'lodash-es/clamp' // Not used\nimport { useSprings, animated } from 'react-spring' // Not used\nimport { useGesture } from 'react-with-gesture' // Not used\n//import './styles.css'\n\nimport tapOrClick from 'react-tap-or-click' // Not used\nimport { useSwipeable } from 'react-swipeable' // Not used\n\nimport Drawer from 'react-motion-drawer'\nimport Flatlist from 'flatlist-react'\n\nimport EventComponent from './EventComponent.js'\n\nimport comics_json_LOCAL from './comics.json'\n\n//var comics_json_LOCAL = null\n\n//import { fetchJSON } from './utils/comicUtils.js'\n\nfunction pad(val) {\n    var s = String(val)\n    const size = 3;\n    while (s.length < (size || 2)) {s = \"0\" + s;}\n    return s;\n}\n/*\ninterface Number {\n    pad: () => string;\n    str: () => string;\n}\n\nNumber.prototype.pad = function() : string {\n    var s = String(this);\n    const size = 3;\n    while (s.length < (size || 2)) {s = \"0\" + s;}\n    return s;\n}\n\nNumber.prototype.str = function() : string {\n    return String(this)\n}\n*/\n\nconst pages = [\n    'https://images.pexels.com/photos/62689/pexels-photo-62689.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260',\n    'https://images.pexels.com/photos/296878/pexels-photo-296878.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260',\n    'https://images.pexels.com/photos/1509428/pexels-photo-1509428.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260',\n    'https://images.pexels.com/photos/351265/pexels-photo-351265.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260',\n    'https://images.pexels.com/photos/924675/pexels-photo-924675.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260'\n]\n\nlet Viewpager = () => {\n    const index = useRef(0)\n\n    const [props, set] = useSprings(pages.length, i => ({ x: i * window.innerWidth, sc: 1, display: 'block' }))\n\n    const bind = useGesture(({ down, delta: [xDelta], direction: [xDir], distance, cancel }) => {\n        if (down && distance > window.innerWidth / 7)\n            cancel((index.current = clamp(index.current + (xDir > 0 ? -1 : 1), 0, pages.length - 1)))\n        set(i => {\n            if (i < index.current - 1 || i > index.current + 1) return { display: 'none' }\n            const x = (i - index.current) * window.innerWidth + (down ? xDelta : 0)\n            const sc = down ? 1 - distance / window.innerWidth / 2 : 1\n            return { x, sc, display: 'block' }\n        })\n    })\n\n    return props.map(({ x, display, sc }, i) => (\n            <animated.div {...bind()} key={i} style={{ display, transform: x.interpolate(x => `translate3d(${x}px,0,0)`) }}>\n            <animated.div style={{ transform: sc.interpolate(s => `scale(${s})`), backgroundImage: `url(${pages[i]})` }} />\n            </animated.div>\n    ))\n}\n\nlet App = () => {\n    const index = useRef(0)\n\n    const [props, set] = useSprings(pages.length, i => ({ x: i * window.innerWidth, sc: 1, display: 'block' }))\n    const bind = useGesture(({ down, delta: [xDelta], direction: [xDir], distance, cancel }) => {\n        if (down && distance > window.innerWidth / 7)\n            cancel((index.current = clamp(index.current + (xDir > 0 ? -1 : 1), 0, pages.length - 1)))\n        set(i => {\n            if (i < index.current - 1 || i > index.current + 1) return { display: 'none' }\n            const x = (i - index.current) * window.innerWidth + (down ? xDelta : 0)\n            const sc = down ? 1 - distance / window.innerWidth / 2 : 1\n            return { x, sc, display: 'block' }\n        })\n    })\n\n    const api_root = \"https://comic-editor.s3.eu-north-1.amazonaws.com\"\n    const comic_name = \"One Piece - Digital Colored Comics\"\n\n    //const [comics_json, setComicsJson] = useState(comics_json_LOCAL ? comics_json_LOCAL : null)\n    const [comics_json, setComicsJson] = useState()\n\n    const [comics_labels, setComicsLabels] = useState([])\n    const [comic_data, setComicData] = useState([])\n    const [comic_images, setComicImages] = useState([])\n\n    const [chapter_nr, setChapterNr] = useState(523) //523\n    const [chapter_name, setChapterName] = useState()\n    const [page_nr, setPageNr] = useState(1)\n    const [page_count, setPageCount] = useState(0)\n    const [source_arr, setSourceArr] = useState([])\n\n    const [hq_enabled, setHQEnabled] = useState(false)\n    const [has_hq, setHasHQ] = useState(false)\n    const [preload_images, setPreloadImages] = useState(true)\n\n    const [pages_data, setPagesData] = useState([])\n    const [swiped, setSwiped] = useState(false)\n    const [is_drawer_open, setIsDrawerOpen] = useState(false)\n\n    const [current_label, setCurrentLabel] = useState()\n\n    useEffect(() => {fetchComics(comics_json)}, [comics_json]);\n    //useEffect(() => {getComicsLabels(comics_labels)}, [comics_json, comic_name])\n    //useEffect(() => {getComicData(comic_data)}, [comics_json, chapter_nr])\n\n\n    const getComicData = () => {\n        //if(isNaN(comics_json)) return;\n        //let comic_data = comics_json[comic_name]\n    }\n\n    const getComicImages = (new_chapter) => {\n\tif(! preload_images) return;\n\tfor(var i=1;i <= new_chapter.count;i++) {\n\t\tnew Image().src = encodeURI(`${api_root}/${comic_name}/${new_chapter.label}/${new_chapter.hq && hq_enabled?\"hq/\":\"\"}${pad(i)}.png`)\n\t\t//new Image().src = encodeURI(`${api_root}/${comic_name}/${new_chapter.label}/${pad(i)}.png`)\n\t}\n    }\n\n    const getComicsLabels = (json) => {\n        //if(isNaN(json)) return;\n        let labels = [];\n        Object.entries(json[comic_name]).forEach(function(chapter, index) {\n            let title = chapter[1]['t']\n            let count = chapter[1]['c']\n            let hq    = chapter[1]['h']\n            labels[index] = { value: index, label: title, count: count, hq: hq}\n        })\n        setComicsLabels(labels)\n\tchangeChapter(labels, chapter_nr, 1)\n\tgetComicImages(labels[chapter_nr]);\n        //setPage(labels[chapter_nr], 1)\n\t//setPageCount(count)\n    }\n\n    const fetchComics = async () => {\n\tif(comics_json) return;\n\tif(comics_json_LOCAL) {\n\t\tsetComicsJson(comics_json_LOCAL)\n\t\tgetComicsLabels(comics_json_LOCAL)\n\t\treturn;\n\t}\n        try {\n            const response = await fetch(encodeURI(`${api_root}/comics.json`))\n            let json = await response.json()\n            //let labels = []\n            //Object.keys(json).forEach(function(index) {labels[index] = json[index]})\n            setComicsJson(json);\n\t    getComicsLabels(json)\n        } catch(error) {\n            console.error(error)\n        }\n    };\n\n    const handleClick = (event) => {\n\t//console.log(event);\n        if(event.type === \"mouseclick\") {\n            alert(event)\n        }\n    }\n\n    const setPage = (data, nr=null) => {\n\tif(typeof(nr) !== \"number\") nr=1;\n\tconsole.log(data)\n\t//if(data.value !== chapter_nr) {\n\t\t//changeChapter(data.value)\n\t\t//return\n\t//}\n        setPageNr(nr)\n\tsetCurrentLabel(data)\n        setSourceArr(encodeURI(`${api_root}/${comic_name}/${data.label}/${data.hq && hq_enabled?\"hq/\":\"\"}${pad(nr)}.png`))\n    }\n\n    const changeChapter = (labels, new_chapter_nr, new_page_nr) => {\n\n        setChapterName(labels[new_chapter_nr].label)\n        setChapterNr(new_chapter_nr)\n        setHasHQ(labels[new_chapter_nr].hq)\n\tsetPage(labels[new_chapter_nr], new_page_nr)\n    }\n\n    const prevChapter = () => {\n\t    changeChapter(comics_labels, chapter_nr-1, comics_labels[chapter_nr-1].count-1)\n    }\n    const nextChapter = () => {\n\t    getComicImages(comics_labels[chapter_nr-1]);\n\t    changeChapter(comics_labels, chapter_nr-1, 1)\n    }\n\n\n    const nextPage = () => {\n\tconsole.log(\"Next Page\")\n\tif(page_nr+1 >= comics_labels[chapter_nr].count) {\n\t\tnextChapter();\n\t\t//changeChapter(comics_labels, chapter_nr+1, 1)\n\t} else {\n\t\tsetPage(comics_labels[chapter_nr], page_nr+1)\n\t}\n\tif(page_nr === comics_labels[chapter_nr].count/2) {\n\t\tgetComicImages(comics_labels[chapter_nr+1])\n\t}\n    }\n    const prevPage = () => {\n\tconsole.log(\"Prev Page\")\n\tif (page_nr-1 <= 0) {\n\t\tprevChapter();\n\t\t//changeChapter(comics_labels, chapter_nr-1, comics_labels[chapter_nr-1].count-1)\n\t} else {\n\t\tsetPage(comics_labels[chapter_nr], page_nr-1)\n\t}\n\tif(page_nr+1 === comics_labels[chapter_nr].count/2) {\n\t\tgetComicImages(comics_labels[chapter_nr-1])\n\t}\n    }\n    const onTap = (touch) => {\n\t//console.log(touch.clientX)\n\tconst sideMargin = window.innerWidth / 6;\n\tif(touch.clientX < sideMargin) {\n\t\tnextPage();\n\t} else\n\tif(touch.clientX > window.innerWidth - sideMargin) {\n\t\tprevPage();\n\t}\n    }\n\n    /*\n    return props.map(({ x, display, sc }, i) => (\n            <animated.div {...bind()} key={i} style={{ display, transform: x.interpolate(x => `translate3d(${x}px,0,0)`) }}>\n            <animated.div style={{ transform: sc.interpolate(s => `scale(${s})`), backgroundImage: `url(${pages[i]})` }} />\n            </animated.div>\n    ))\n    */\n\n    const handlers = useSwipeable({\n        onSwipedLeft: () => console.warn(\"Alternative swipe Left\"),\n        onSwipedRight: () => console.warn(\"Alternative swipe Right\"),\n        preventDefaultTouchmoveEvent: true,\n        trackMouse: true\n    })\n\n    const listChange = (e) => {\n\t    console.log(e)\n    }\n\n    const renderLabel = (label) => {\n\t    return(<li key={label.key} onClick={() => changeChapter(comics_labels, label.value, 1)}><b>{label.value}</b></li>)\n\t    //return(<li key={label.key} onClick={() => setPage(label)}><b>{label.value}</b></li>)\n    }\n\n    return (\n        <>\n        {comics_labels && false ? <Dropdown options={comics_labels} onChange={setPage} value={comics_labels[chapter_nr]} placeholder=\"Select an option\" /> : null}\n        {\n              //comic_images ? <Dropdown options={comic_images} onChange={setPage} value={comic_images[page_nr]} placeholder=\"Select an option\" /> : null\n        }\n\t<Drawer open={is_drawer_open} onChange={setIsDrawerOpen}>\n        {comics_labels && false ? <Select options={comics_labels} onChange={setPage} value={current_label} placeholder=\"Select an option\" /> : null}\n        {comics_labels && true ? <Flatlist list={comics_labels} onChange={setPage} value={current_label} placeholder=\"Select an option\" renderItem={renderLabel} /> : null}\n        {comics_labels && false ? <Dropdown id=\"dropdown\" options={comics_labels} onChange={setPage} value={comics_labels[chapter_nr]} /> : null}\n\t<ul>\n\t{ comics_labels && false ? comics_labels.map(function(label) {\n\t\t//return <li>i</li>\n    \t\t//const changeChapter = (labels, new_chapter_nr, new_page_nr) => {\n\t\t//return (<li key={label.value} onClick={console.log}>{label.value}</li>)\n\t\treturn (<li key={label.value} data-id={\"Test\"} onClick={listChange.bind(this)}>{label.value}</li>)\n\t}) : null}\n\t</ul>\n\t</Drawer>\n        {\n            chapter_name ?\n\t\t<EventComponent onSwiped={setSwiped} onSwipedLeft={nextPage} onSwipedRight={prevPage} onTap={onTap}>\n                <div id=\"img-box\" {...tapOrClick(handleClick)}>\n\n{ false ?\n<>\n\t<b>{`${swiped?'Swiped':'Not Swiped'}`}</b>\n\t<b>{`${page_nr}`}</b>\n</>\n: null}\n\t{window.scrollTo(0, 0)}\n\t\t{false ?\n                <ReactImageAppear id=\"img-background\" {...handlers}\n            src={encodeURI(`${api_root}/${comic_name}/${chapter_name}${has_hq && hq_enabled?\"/hq/\":\"/\"}${pad(page_nr)}.png?${new Date().getTime()}`)} placeholder={encodeURI(`${api_root}/${comic_name}/${chapter_name}/${pad(page_nr)}.png`)} showLoader={false} animationDuration={'0'}/>\n:\n                true ? <img\n\t\t id=\"img-background\"\n\t\t alt=\"\"\n\t\tsrc={source_arr} // source_arr\n\t\t//src={\"https://via.placeholder.com/480x640\"}\n\t\t{...handlers} showLoader={false} animationDuration={'0'}/> : null\n}\n</div>\n</EventComponent>\n                        : null\n        }\n            { false ? <button onClick={nextPage}>Next</button> : null}\n\n        </>\n    )\n}\n\n                    //<animated.div style={{ transform: sc.interpolate(s => `scale(${s})`), backgroundImage: `url(${pages[i]})` }} />\nexport default hot(module)(App);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n//serviceWorker.unregister();\n"],"sourceRoot":""}