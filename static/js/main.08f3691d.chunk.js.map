{"version":3,"sources":["EventComponent.js","LabelList.js","App.js","serviceWorker.js","index.js"],"names":["EventComponent","props","_onTouchStart","bind","_onTouchMove","_onTouchEnd","state","swiped","_swipe","minDistance","e","touch","touches","length","this","setState","x","clientX","y","clientY","changedTouches","swiping","absX","Math","abs","absY","onSwiped","onSwipedRight","onSwipedLeft","onTap","onTouchStart","onTouchMove","onTouchEnd","children","React","Component","cache","CellMeasurerCache","fixedWidth","defaultHeight","pad","val","s","String","pages","App","index","useRef","useSprings","i","window","innerWidth","sc","display","set","api_root","useGesture","down","xDelta","delta","xDir","direction","distance","cancel","current","clamp","comic_name","useState","comics_json","setComicsJson","comics_labels","setComicsLabels","chapter_nr","setChapterNr","chapter_name","setChapterName","page_nr","setPageNr","source_arr","setSourceArr","hq_enabled","setHQEnabled","setHasHQ","preload_images","setSwiped","is_drawer_open","setIsDrawerOpen","setCurrentLabel","listRef","useEffect","fetchComics","getComicsLabels","json","labels","Object","entries","forEach","chapter","title","count","hq","value","label","Image","src","encodeURI","changeChapter","a","comics_json_LOCAL","fetch","response","console","error","setPage","data","nr","log","new_chapter_nr","new_page_nr","nextPage","new_chapter","getComicImages","prevPage","handlers","useSwipeable","warn","preventDefaultTouchmoveEvent","trackMouse","renderLabel","key","style","id","onClick","open","onChange","width","height","ref","rowCount","rowHeight","rowRenderer","scrollToIndex","renderItem","sideMargin","tapOrClick","event","type","alert","scrollTo","alt","showLoader","animationDuration","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.08f3691d.chunk.js","sourcesContent":["import React from 'react';\n\nexport default class EventComponent extends React.Component {\n\n  constructor(props) {\n    super(props);\n\n    this._onTouchStart = this._onTouchStart.bind(this);\n    this._onTouchMove = this._onTouchMove.bind(this);\n    this._onTouchEnd = this._onTouchEnd.bind(this);\n\n    this.state = { swiped: false };\n    this._swipe = {};\n    this.minDistance = 50;\n  }\n\n  _onTouchStart(e) {\n    const touch = e.touches[0];\n\t// If multiple touches? Ignore ?\n\tif (e.touches.length > 1) {\n\t\tthis._swipe = {}\n\t\tthis.setState({ swiped: false })\n\t\treturn\n\t}\n    this._swipe = { x: touch.clientX, y: touch.clientY };\n    this.setState({ swiped: false });\n  }\n\n  _onTouchMove(e) {\n    if (e.changedTouches && e.changedTouches.length) {\n      const touch = e.changedTouches[0];\n      this._swipe.swiping = true;\n    }\n  }\n\n  _onTouchEnd(e) {\n    const touch = e.changedTouches[0];\n\n    if( !this._swipe.swiping) {\n\t    this.props.onTap && this.props.onTap(touch)\n\t    return\n    }\n    const absX = Math.abs(touch.clientX - this._swipe.x);\n    const absY = Math.abs(touch.clientY - this._swipe.y);\n    // Don't swip if AbY is too high\n    if(this._swipe.swiping && absY > 80) {\n\tthis._swipe = {}\n\treturn\n\t}\n\n    if (this._swipe.swiping && absX > this.minDistance ) {\n      this.props.onSwiped(true);\n      this.setState({ swiped: true });\n      if(touch.clientX < this._swipe.x) {\n\t      // Swipe Right\n\t\tthis.props.onSwipedRight && this.props.onSwipedRight();\n      }\n      if(touch.clientX > this._swipe.x) {\n\t      // Swipe Left\n\t\tthis.props.onSwipedLeft && this.props.onSwipedLeft();\n\n      }\n    }\n    this._swipe = {};\n  }\n\n  render() {\n    return (\n      <div\n        onTouchStart={this._onTouchStart}\n        onTouchMove={this._onTouchMove}\n        onTouchEnd={this._onTouchEnd}>\n        { false ? `Component-${this.state.swiped ? 'swiped' : ''}` : null}\n\t{this.props.children}\n      </div>\n    );\n  }\n\n}\n","import React, { Component } from \"react\";\nimport {\n  AutoSizer,\n  CellMeasurer,\n  CellMeasurerCache,\n  InfiniteLoader,\n  List,\n  WindowScroller\n} from \"react-virtualized\";\n\nconst cache = new CellMeasurerCache({\n  fixedWidth: true,\n  defaultHeight: 100\n});\n\nclass LabelList extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      scrollToIndex: -1,\n      list: props.list\n    };\n    this.handleClick = this.handleClick.bind(this);\n    this.loadMoreRows = this.loadMoreRows.bind(this);\n    this.isRowLoaded = this.isRowLoaded.bind(this);\n    this.clearScrollToIndex = this.clearScrollToIndex.bind(this);\n  }\n\n  clearScrollToIndex() {\n    this.setState({ scrollToIndex: -1 });\n  }\n\n  handleClick() {\n    this.setState({\n      scrollToIndex: Number(this.inputRow.value)\n    });\n  }\n\n  isRowLoaded({ index }) {\n    const { list } = this.state;\n    return !!list[index];\n  }\n\n  loadMoreRows({ startIndex, stopIndex }) {\n    console.log(\"load more\", startIndex, stopIndex);\n  }\n\n  rowRenderer({ index, isScrolling, isVisible, key, parent, style }) {\n    if (isScrolling) {\n      return null;\n    }\n\n    if (isVisible) {\n      return (\n        <CellMeasurer\n          key={key}\n          cache={cache}\n          parent={parent}\n          columnIndex={0}\n          rowIndex={index}\n        >\n          <div style={style}>this is row: {index}</div>\n        </CellMeasurer>\n      );\n    }\n    return null;\n  }\n\n  render() {\n    if (this.state.list.length === 0) {\n      return <div>No data available.</div>;\n    }\n\n    const scrollToIndex = this.state.scrollToIndex;\n\n    return (\n      <div>\n        <div>\n          <input\n            type=\"number\"\n            ref={input => {\n              this.inputRow = input;\n            }}\n          />\n          <input\n            type=\"button\"\n            value=\"Scroll To Row\"\n            onClick={this.handleClick}\n          />\n        </div>\n        <InfiniteLoader\n          isRowLoaded={this.isRowLoaded}\n          loadMoreRows={loadMoreRows => this.loadMoreRows(loadMoreRows)}\n          rowCount={2000}\n          threshold={15}\n        >\n          {({ onRowsRendered, registerChild }) => (\n            <WindowScroller onScroll={this.clearScrollToIndex}>\n              {({ height, isScrolling, onChildScroll, scrollTop }) => (\n                <AutoSizer disableHeight>\n                  {({ width }) => {\n                    console.log(\"scroll to index\", scrollToIndex);\n                    return (\n                      <List\n                        autoHeight\n                        height={height}\n                        onRowsRendered={onRowsRendered}\n                        ref={registerChild}\n                        width={width}\n                        rowCount={2000}\n                        rowHeight={cache.rowHeight}\n                        rowRenderer={rowRenderer =>\n                          this.rowRenderer(rowRenderer)\n                        }\n                        scrollTop={scrollTop}\n                        deferredMeasurementCache={cache}\n                        style={{ paddingLeft: \"0\", paddingRight: \"0\" }}\n                        scrollToAlignment=\"start\"\n                        scrollToIndex={scrollToIndex}\n                        onScroll={onChildScroll}\n                      />\n                    );\n                  }}\n                </AutoSizer>\n              )}\n            </WindowScroller>\n          )}\n        </InfiniteLoader>\n      </div>\n    );\n  }\n}\n\nexport default LabelList;\n","import { render } from 'react-dom'\nimport React, { useEffect, useState, useRef} from 'react';\nimport { hot } from 'react-hot-loader';\nimport Img from 'react-image'\nimport ReactImageAppear from 'react-image-appear'\nimport './App.css';\n\n//import axios from 'axios'\nimport Dropdown from 'react-dropdown'\nimport 'react-dropdown/style.css'\nimport Select from 'react-select'\n\n//import { Swipeable, defineSwipe } from 'react-touch'\n\nimport clamp from 'lodash-es/clamp' // Not used\nimport { useSprings, animated } from 'react-spring' // Not used\nimport { useGesture } from 'react-with-gesture' // Not used\n//import './styles.css'\n\nimport tapOrClick from 'react-tap-or-click' // Not used\nimport { useSwipeable } from 'react-swipeable' // Not used\n\nimport Drawer from 'react-motion-drawer'\nimport Flatlist from 'flatlist-react'\n\n//import AutoSize from 'react-virtualized'\n\nimport AutoSize from 'react-virtualized/dist/commonjs/AutoSizer'\nimport List from 'react-virtualized/dist/commonjs/List'\n\nimport EventComponent from './EventComponent.js'\nimport LabelList from './LabelList.js'\n\nimport comics_json_LOCAL from './comics.json'\n\n//var comics_json_LOCAL = null\n\n//import { fetchJSON } from './utils/comicUtils.js'\n\nfunction pad(val) {\n    var s = String(val)\n    const size = 3;\n    while (s.length < (size || 2)) {s = \"0\" + s;}\n    return s;\n}\n/*\ninterface Number {\n    pad: () => string;\n    str: () => string;\n}\n\nNumber.prototype.pad = function() : string {\n    var s = String(this);\n    const size = 3;\n    while (s.length < (size || 2)) {s = \"0\" + s;}\n    return s;\n}\n\nNumber.prototype.str = function() : string {\n    return String(this)\n}\n*/\n\nconst pages = [\n    'https://images.pexels.com/photos/62689/pexels-photo-62689.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260',\n    'https://images.pexels.com/photos/296878/pexels-photo-296878.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260',\n    'https://images.pexels.com/photos/1509428/pexels-photo-1509428.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260',\n    'https://images.pexels.com/photos/351265/pexels-photo-351265.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260',\n    'https://images.pexels.com/photos/924675/pexels-photo-924675.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260'\n]\n\nlet Viewpager = () => {\n    const index = useRef(0)\n\n    const [props, set] = useSprings(pages.length, i => ({ x: i * window.innerWidth, sc: 1, display: 'block' }))\n\n    const bind = useGesture(({ down, delta: [xDelta], direction: [xDir], distance, cancel }) => {\n        if (down && distance > window.innerWidth / 7)\n            cancel((index.current = clamp(index.current + (xDir > 0 ? -1 : 1), 0, pages.length - 1)))\n        set(i => {\n            if (i < index.current - 1 || i > index.current + 1) return { display: 'none' }\n            const x = (i - index.current) * window.innerWidth + (down ? xDelta : 0)\n            const sc = down ? 1 - distance / window.innerWidth / 2 : 1\n            return { x, sc, display: 'block' }\n        })\n    })\n\n    return props.map(({ x, display, sc }, i) => (\n            <animated.div {...bind()} key={i} style={{ display, transform: x.interpolate(x => `translate3d(${x}px,0,0)`) }}>\n            <animated.div style={{ transform: sc.interpolate(s => `scale(${s})`), backgroundImage: `url(${pages[i]})` }} />\n            </animated.div>\n    ))\n}\n\nlet App = () => {\n    const index = useRef(0)\n\n    const [props, set] = useSprings(pages.length, i => ({ x: i * window.innerWidth, sc: 1, display: 'block' }))\n    const bind = useGesture(({ down, delta: [xDelta], direction: [xDir], distance, cancel }) => {\n        if (down && distance > window.innerWidth / 7)\n            cancel((index.current = clamp(index.current + (xDir > 0 ? -1 : 1), 0, pages.length - 1)))\n        set(i => {\n            if (i < index.current - 1 || i > index.current + 1) return { display: 'none' }\n            const x = (i - index.current) * window.innerWidth + (down ? xDelta : 0)\n            const sc = down ? 1 - distance / window.innerWidth / 2 : 1\n            return { x, sc, display: 'block' }\n        })\n    })\n\n    const api_root = \"https://comic-editor.s3.eu-north-1.amazonaws.com\"\n    const comic_name = \"One Piece - Digital Colored Comics\"\n\n    //const [comics_json, setComicsJson] = useState(comics_json_LOCAL ? comics_json_LOCAL : null)\n    const [comics_json, setComicsJson] = useState()\n\n    const [comics_labels, setComicsLabels] = useState([])\n    const [comic_data, setComicData] = useState([])\n    const [comic_images, setComicImages] = useState([])\n\n    const [chapter_nr, setChapterNr] = useState(524) //523\n    const [chapter_name, setChapterName] = useState()\n    const [page_nr, setPageNr] = useState(1)\n    const [page_count, setPageCount] = useState(0)\n    const [source_arr, setSourceArr] = useState([])\n\n    const [hq_enabled, setHQEnabled] = useState(false)\n    const [has_hq, setHasHQ] = useState(false)\n    const [preload_images, setPreloadImages] = useState(true)\n\n    const [pages_data, setPagesData] = useState([])\n    const [swiped, setSwiped] = useState(false)\n    const [is_drawer_open, setIsDrawerOpen] = useState(false)\n\n    const [current_label, setCurrentLabel] = useState()\n    const listRef = useRef(null);\n\n    useEffect(() => {fetchComics(comics_json)}, [comics_json]);\n    //useEffect(() => {getComicsLabels(comics_labels)}, [comics_json, comic_name])\n    //useEffect(() => {getComicData(comic_data)}, [comics_json, chapter_nr])\n\n\n    const getComicData = () => {\n        //if(isNaN(comics_json)) return;\n        //let comic_data = comics_json[comic_name]\n    }\n\n    const getComicImages = (new_chapter) => {\n\tif(! preload_images) return;\n\tfor(var i=1;i <= new_chapter.count;i++) {\n\t\tnew Image().src = encodeURI(`${api_root}/${comic_name}/${new_chapter.label}/${new_chapter.hq && hq_enabled?\"hq/\":\"\"}${pad(i)}.png`)\n\t\t//new Image().src = encodeURI(`${api_root}/${comic_name}/${new_chapter.label}/${pad(i)}.png`)\n\t}\n    }\n\n    const getComicsLabels = (json) => {\n        //if(isNaN(json)) return;\n        let labels = [];\n        Object.entries(json[comic_name]).forEach(function(chapter, index) {\n            let title = chapter[1]['t']\n            let count = chapter[1]['c']\n            let hq    = chapter[1]['hq']\n            labels[index] = { value: index, label: title, count: count, hq: hq}\n        })\n        setComicsLabels(labels)\n\tnew Image().src = encodeURI(`${api_root}/${comic_name}/${labels[chapter_nr].label}/${labels[chapter_nr].hq && hq_enabled?\"hq/\":\"\"}${pad(2)}.png`) // Preload the Second Image\n\tchangeChapter(labels, chapter_nr, 1)\n\t//getComicImages(labels[chapter_nr]);\n        //setPage(labels[chapter_nr], 1)\n\t//setPageCount(count)\n    }\n\n    const fetchComics = async () => {\n\tif(comics_json) return;\n\tif(comics_json_LOCAL) {\n\t\tsetComicsJson(comics_json_LOCAL)\n\t\tgetComicsLabels(comics_json_LOCAL)\n\t\treturn;\n\t}\n        try {\n            const response = await fetch(encodeURI(`${api_root}/comics.json`))\n            let json = await response.json()\n            //let labels = []\n            //Object.keys(json).forEach(function(index) {labels[index] = json[index]})\n            setComicsJson(json);\n\t    getComicsLabels(json)\n        } catch(error) {\n            console.error(error)\n        }\n    };\n\n    const handleClick = (event) => {\n\t//console.log(event);\n        if(event.type === \"mouseclick\") {\n            alert(event)\n        }\n    }\n\n    const setPage = (data, nr=null) => {\n\tif(typeof(nr) !== \"number\") nr=1;\n\tconsole.log(data)\n\t//if(data.value !== chapter_nr) {\n\t\t//changeChapter(data.value)\n\n\t\t//return\n\t//}\n        setPageNr(nr)\n\tsetCurrentLabel(data)\n        setSourceArr(encodeURI(`${api_root}/${comic_name}/${data.label}/${data.hq && hq_enabled?\"hq/\":\"\"}${pad(nr)}.png`))\n    }\n\n    const changeChapter = (labels, new_chapter_nr, new_page_nr) => {\n\t//getComicImages(labels[new_chapter_nr])\n        setChapterName(labels[new_chapter_nr].label)\n        setChapterNr(new_chapter_nr)\n        setHasHQ(labels[new_chapter_nr].hq)\n\tsetPage(labels[new_chapter_nr], new_page_nr)\n\tnew Image().src = encodeURI(`${api_root}/${comic_name}/${labels[new_chapter_nr].label}/${labels[new_chapter_nr].hq && hq_enabled?\"hq/\":\"\"}${pad(2)}.png`) // Preload the Second Image\n    }\n\n    const prevChapter = () => {\n\t    changeChapter(comics_labels, chapter_nr-1, comics_labels[chapter_nr-1].count-1)\n    }\n    const nextChapter = () => {\n\t    changeChapter(comics_labels, chapter_nr+1, 1)\n    }\n\n\n    const nextPage = () => {\n\tconsole.log(\"Next Page\")\n\tif(page_nr+1 >= comics_labels[chapter_nr].count) {\n\t\tnextChapter();\n\t\t//changeChapter(comics_labels, chapter_nr+1, 1)\n\t} else {\n\t\tsetPage(comics_labels[chapter_nr], page_nr+1)\n\t}\n\tif(page_nr+1 === 2) {\n\t\tgetComicImages(comics_labels[chapter_nr]) // Preload rest of Images\n\t}\n/*\n\telse\n\tif(page_nr+1 === comics_labels[chapter_nr].count/2) {\n\t\tgetComicImages(comics_labels[chapter_nr+1])\n\t}\n*/\n    }\n    const prevPage = () => {\n\tconsole.log(\"Prev Page\")\n\tif (page_nr-1 <= 0) {\n\t\tprevChapter();\n\t\t//changeChapter(comics_labels, chapter_nr-1, comics_labels[chapter_nr-1].count-1)\n\t} else {\n\t\tsetPage(comics_labels[chapter_nr], page_nr-1)\n\t}\n/*\n\telse\n\tif(page_nr+1 === comics_labels[chapter_nr].count/2) {\n\t\tgetComicImages(comics_labels[chapter_nr-1])\n\t}\n*/\n    }\n    const onTap = (touch) => {\n\t//console.log(touch.clientX)\n\tconst sideMargin = window.innerWidth / 6;\n\tif(touch.clientX < sideMargin) {\n\t\tnextPage();\n\t} else\n\tif(touch.clientX > window.innerWidth - sideMargin) {\n\t\tprevPage();\n\t}\n    }\n\n    /*\n    return props.map(({ x, display, sc }, i) => (\n            <animated.div {...bind()} key={i} style={{ display, transform: x.interpolate(x => `translate3d(${x}px,0,0)`) }}>\n            <animated.div style={{ transform: sc.interpolate(s => `scale(${s})`), backgroundImage: `url(${pages[i]})` }} />\n            </animated.div>\n    ))\n    */\n\n    const handlers = useSwipeable({\n        onSwipedLeft: () => console.warn(\"Alternative swipe Left\"),\n        onSwipedRight: () => console.warn(\"Alternative swipe Right\"),\n        preventDefaultTouchmoveEvent: true,\n        trackMouse: true\n    })\n\n    const listChange = (e) => {\n\t    console.log(e)\n    }\n\n    const drawerChange = (val) => {\n\tsetIsDrawerOpen(val)\n\tconsole.log(listRef.current)\n\t//console.log(listRef.current.scrollToIndex(chapter_nr+24))\n\t//if(val) listRef.current.scrollToIndex(chapter_nr+24)\n    }\n\n    const renderLabel = ({key, index, style}) => {\n\treturn(\n\t\t//<div key={label.key} onClick={() => changeChapter(comics_labels, label.value, 1)}><b>{(label.value === chapter_nr)?'• ':''}{label.value+1}</b></div>\n\t\t<div id=\"list-label\" key={key} style={style} onClick={() => changeChapter(comics_labels, index, 1)}>{(index === chapter_nr)?'• ':' '}{true?\"Chapter: \"+(index+1):comics_labels[index].label}</div>\n\t)\n\t    //return(<li key={label.key} onClick={() => setPage(label)}><b>{label.value}</b></li>)\n    }\n\n    const reloadSource = (label) => {\n        setSourceArr(encodeURI(`${api_root}/${comic_name}/${label.label}/${label.hq && hq_enabled?\"hq/\":\"\"}${pad(page_nr)}.png`))\n    }\n\n    return (\n        <>\n        {comics_labels && false ? <Dropdown options={comics_labels} onChange={setPage} value={comics_labels[chapter_nr]} placeholder=\"Select an option\" /> : null}\n        {\n              //comic_images ? <Dropdown options={comic_images} onChange={setPage} value={comic_images[page_nr]} placeholder=\"Select an option\" /> : null\n        }\n\t<Drawer open={is_drawer_open} onChange={drawerChange}>\n\t<button onClick={() => (setHQEnabled(!hq_enabled) && changeChapter(comics_labels, chapter_nr, 1))}>Toggle HQ</button>\n        {comics_labels && false ? <Flatlist list={comics_labels} onChange={setPage} scrollToInitialIndex={chapter_nr} renderItem={renderLabel} /> : null}\n        {comics_labels && true ?\n\t<AutoSize>\n\t{({width, height}) => (\n<List\n\tref={listRef}\n\t//ref={(elem) => (elem.current.scrollToIndex(chapter_nr+24))}\n\twidth={width}\n\theight={height}\n\trowCount={comics_labels.length}\n\trowHeight={30}\n\trowRenderer={renderLabel}\n\tscrollToIndex={chapter_nr+24}\n\trenderItem={renderLabel}\n/> )}\n</AutoSize>\n\n\n: null}\n\n\t{ comics_labels && false ? comics_labels.map(function(label) {\n\t\t//return <li>i</li>\n    \t\t//const changeChapter = (labels, new_chapter_nr, new_page_nr) => {\n\t\t//return (<li key={label.value} onClick={console.log}>{label.value}</li>)\n\t\treturn (<li key={label.value} data-id={\"Test\"} onClick={listChange.bind(this)}>{label.value}</li>)\n\t}) : null}\n\t</Drawer>\n        {\n            chapter_name ?\n\t\t<EventComponent onSwiped={setSwiped} onSwipedLeft={nextPage} onSwipedRight={prevPage} onTap={onTap}>\n                <div id=\"img-box\" {...tapOrClick(handleClick)}>\n\n{ false ?\n<>\n\t<b>{`${swiped?'Swiped':'Not Swiped'}`}</b>\n\t<b>{`${page_nr}`}</b>\n</>\n: null}\n\t{window.scrollTo(0, 0)}\n\t\t{false ?\n                <ReactImageAppear id=\"img-background\" {...handlers}\n            src={encodeURI(`${api_root}/${comic_name}/${chapter_name}${has_hq && hq_enabled?\"/hq/\":\"/\"}${pad(page_nr)}.png?${new Date().getTime()}`)} placeholder={encodeURI(`${api_root}/${comic_name}/${chapter_name}/${pad(page_nr)}.png`)} showLoader={false} animationDuration={'0'}/>\n:\n                true ? <img\n\t\t id=\"img-background\"\n\t\t alt=\"\"\n\t\tsrc={source_arr} // source_arr\n\t\t//src={\"https://via.placeholder.com/480x640\"}\n\t\t{...handlers} showLoader={false} animationDuration={'0'}/> : null\n}\n</div>\n</EventComponent>\n                        : null\n        }\n            { false ? <button onClick={nextPage}>Next</button> : null}\n\n        </>\n    )\n}\n\n                    //<animated.div style={{ transform: sc.interpolate(s => `scale(${s})`), backgroundImage: `url(${pages[i]})` }} />\nexport default hot(module)(App);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n//serviceWorker.unregister();\n"],"sourceRoot":""}