{"version":3,"sources":["EventComponent.js","LabelList.js","App.js","serviceWorker.js","index.js"],"names":["EventComponent","props","_onTouchStart","bind","_onTouchMove","_onTouchEnd","state","swiped","_swipe","minDistance","e","touch","touches","length","this","setState","centerX","window","innerWidth","centerMargin","x","clientX","y","clientY","changedTouches","swiping","absX","Math","abs","absY","onSwiped","onSwipedRight","onSwipedLeft","onTap","onTouchStart","onTouchMove","onTouchEnd","children","React","Component","cache","CellMeasurerCache","fixedWidth","defaultHeight","pad","val","s","String","App","useRef","api_root","comic_name","useState","comics_json","setComicsJson","comics_labels","setComicsLabels","chapter_nr","setChapterNr","chapter_name","setChapterName","page_nr","setPageNr","source_arr","setSourceArr","hq_enabled","setHQEnabled","setHasHQ","preload_images","setSwiped","is_drawer_open","setIsDrawerOpen","setCurrentLabel","listRef","useEffect","fetchComics","getComicsLabels","json","labels","Object","entries","forEach","chapter","index","title","count","hq","value","label","Image","src","encodeURI","changeChapter","a","comics_json_LOCAL","fetch","response","console","error","setPage","data","nr","log","new_chapter_nr","new_page_nr","nextPage","new_chapter","i","getComicImages","prevPage","handlers","useSwipeable","warn","preventDefaultTouchmoveEvent","trackMouse","renderLabel","key","style","id","onClick","open","onChange","current","width","height","ref","rowCount","rowHeight","rowRenderer","scrollToIndex","renderItem","sideMargin","tapOrClick","event","type","alert","scrollTo","alt","showLoader","animationDuration","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.d2c7a8a6.chunk.js","sourcesContent":["import React from 'react';\n\nexport default class EventComponent extends React.Component {\n\n  constructor(props) {\n    super(props);\n\n    this._onTouchStart = this._onTouchStart.bind(this);\n    this._onTouchMove = this._onTouchMove.bind(this);\n    this._onTouchEnd = this._onTouchEnd.bind(this);\n\n    this.state = { swiped: false };\n    this._swipe = {};\n    this.minDistance = 50;\n    //this.centerMargin = 600;\n  }\n\n  _onTouchStart(e) {\n    const touch = e.touches[0];\n    // If multiple touches? Ignore ?\n    if (e.touches.length > 1) {\n      this._swipe = {}\n      this.setState({ swiped: false })\n      return\n    }\n    const centerX = window.innerWidth / 2;\n    const centerMargin = centerX / 2;\n    const x = touch.clientX;\n    if ( x > centerX - centerMargin && x < centerX + centerMargin) {\n      this._swipe = {}\n      this.setState({ swiped: false });\n      return\n    }\n    this._swipe = { x: touch.clientX, y: touch.clientY };\n    this.setState({ swiped: false });\n  }\n\n  _onTouchMove(e) {\n    if (e.changedTouches && e.changedTouches.length) {\n      //const touch = e.changedTouches[0];\n      this._swipe.swiping = true;\n    }\n  }\n\n  _onTouchEnd(e) {\n    const touch = e.changedTouches[0];\n\n    if( !this._swipe.swiping) {\n      this.props.onTap && this.props.onTap(touch)\n      return\n    }\n    const absX = Math.abs(touch.clientX - this._swipe.x);\n    const absY = Math.abs(touch.clientY - this._swipe.y);\n    // Don't swip if AbY is too high\n    if(this._swipe.swiping && absY > 80) {\n      this._swipe = {}\n      return\n    }\n\n    if (this._swipe.swiping && absX > this.minDistance ) {\n      this.props.onSwiped(true);\n      this.setState({ swiped: true });\n      if(touch.clientX < this._swipe.x) {\n        // Swipe Right\n        this.props.onSwipedRight && this.props.onSwipedRight();\n      }\n      if(touch.clientX > this._swipe.x) {\n        // Swipe Left\n        this.props.onSwipedLeft && this.props.onSwipedLeft();\n\n      }\n    }\n    this._swipe = {};\n  }\n\n  render() {\n    return (\n      <div\n        onTouchStart={this._onTouchStart}\n        onTouchMove={this._onTouchMove}\n        onTouchEnd={this._onTouchEnd}>\n        { false ? `Component-${this.state.swiped ? 'swiped' : ''}` : null}\n        {this.props.children}\n      </div>\n    );\n  }\n\n}\n","import React, { Component } from \"react\";\nimport {\n  AutoSizer,\n  CellMeasurer,\n  CellMeasurerCache,\n  InfiniteLoader,\n  List,\n  WindowScroller\n} from \"react-virtualized\";\n\nconst cache = new CellMeasurerCache({\n  fixedWidth: true,\n  defaultHeight: 100\n});\n\nclass LabelList extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      scrollToIndex: -1,\n      list: props.list\n    };\n    this.handleClick = this.handleClick.bind(this);\n    this.loadMoreRows = this.loadMoreRows.bind(this);\n    this.isRowLoaded = this.isRowLoaded.bind(this);\n    this.clearScrollToIndex = this.clearScrollToIndex.bind(this);\n  }\n\n  clearScrollToIndex() {\n    this.setState({ scrollToIndex: -1 });\n  }\n\n  handleClick() {\n    this.setState({\n      scrollToIndex: Number(this.inputRow.value)\n    });\n  }\n\n  isRowLoaded({ index }) {\n    const { list } = this.state;\n    return !!list[index];\n  }\n\n  loadMoreRows({ startIndex, stopIndex }) {\n    console.log(\"load more\", startIndex, stopIndex);\n  }\n\n  rowRenderer({ index, isScrolling, isVisible, key, parent, style }) {\n    if (isScrolling) {\n      return null;\n    }\n\n    if (isVisible) {\n      return (\n        <CellMeasurer\n          key={key}\n          cache={cache}\n          parent={parent}\n          columnIndex={0}\n          rowIndex={index}\n        >\n          <div style={style}>this is row: {index}</div>\n        </CellMeasurer>\n      );\n    }\n    return null;\n  }\n\n  render() {\n    if (this.state.list.length === 0) {\n      return <div>No data available.</div>;\n    }\n\n    const scrollToIndex = this.state.scrollToIndex;\n\n    return (\n      <div>\n        <div>\n          <input\n            type=\"number\"\n            ref={input => {\n              this.inputRow = input;\n            }}\n          />\n          <input\n            type=\"button\"\n            value=\"Scroll To Row\"\n            onClick={this.handleClick}\n          />\n        </div>\n        <InfiniteLoader\n          isRowLoaded={this.isRowLoaded}\n          loadMoreRows={loadMoreRows => this.loadMoreRows(loadMoreRows)}\n          rowCount={2000}\n          threshold={15}\n        >\n          {({ onRowsRendered, registerChild }) => (\n            <WindowScroller onScroll={this.clearScrollToIndex}>\n              {({ height, isScrolling, onChildScroll, scrollTop }) => (\n                <AutoSizer disableHeight>\n                  {({ width }) => {\n                    console.log(\"scroll to index\", scrollToIndex);\n                    return (\n                      <List\n                        autoHeight\n                        height={height}\n                        onRowsRendered={onRowsRendered}\n                        ref={registerChild}\n                        width={width}\n                        rowCount={2000}\n                        rowHeight={cache.rowHeight}\n                        rowRenderer={rowRenderer =>\n                          this.rowRenderer(rowRenderer)\n                        }\n                        scrollTop={scrollTop}\n                        deferredMeasurementCache={cache}\n                        style={{ paddingLeft: \"0\", paddingRight: \"0\" }}\n                        scrollToAlignment=\"start\"\n                        scrollToIndex={scrollToIndex}\n                        onScroll={onChildScroll}\n                      />\n                    );\n                  }}\n                </AutoSizer>\n              )}\n            </WindowScroller>\n          )}\n        </InfiniteLoader>\n      </div>\n    );\n  }\n}\n\nexport default LabelList;\n","import { render } from 'react-dom'\nimport React, { useEffect, useState, useRef} from 'react';\nimport { hot } from 'react-hot-loader';\nimport Img from 'react-image'\nimport ReactImageAppear from 'react-image-appear'\nimport './App.css';\n\n//import axios from 'axios'\nimport Dropdown from 'react-dropdown'\nimport 'react-dropdown/style.css'\nimport Select from 'react-select'\n\n//import { Swipeable, defineSwipe } from 'react-touch'\n\nimport clamp from 'lodash-es/clamp' // Not used\nimport { useSprings, animated } from 'react-spring' // Not used\nimport { useGesture } from 'react-with-gesture' // Not used\n//import './styles.css'\n\nimport tapOrClick from 'react-tap-or-click' // Not used\nimport { useSwipeable } from 'react-swipeable' // Not used\n\nimport Drawer from 'react-motion-drawer'\nimport Flatlist from 'flatlist-react'\n\n//import AutoSize from 'react-virtualized'\n\nimport AutoSize from 'react-virtualized/dist/commonjs/AutoSizer'\nimport List from 'react-virtualized/dist/commonjs/List'\n\nimport EventComponent from './EventComponent.js'\nimport LabelList from './LabelList.js'\n\nimport comics_json_LOCAL from './comics.json'\n\n//var comics_json_LOCAL = null\n\n//import { fetchJSON } from './utils/comicUtils.js'\n\nfunction pad(val) {\n    var s = String(val)\n    const size = 3;\n    while (s.length < (size || 2)) {s = \"0\" + s;}\n    return s;\n}\n/*\ninterface Number {\n    pad: () => string;\n    str: () => string;\n}\n\nNumber.prototype.pad = function() : string {\n    var s = String(this);\n    const size = 3;\n    while (s.length < (size || 2)) {s = \"0\" + s;}\n    return s;\n}\n\nNumber.prototype.str = function() : string {\n    return String(this)\n}\n*/\n\n/*\nlet Viewpager = () => {\n    const index = useRef(0)\n\n    const [props, set] = useSprings(pages.length, i => ({ x: i * window.innerWidth, sc: 1, display: 'block' }))\n\n    const bind = useGesture(({ down, delta: [xDelta], direction: [xDir], distance, cancel }) => {\n        if (down && distance > window.innerWidth / 7)\n            cancel((index.current = clamp(index.current + (xDir > 0 ? -1 : 1), 0, pages.length - 1)))\n        set(i => {\n            if (i < index.current - 1 || i > index.current + 1) return { display: 'none' }\n            const x = (i - index.current) * window.innerWidth + (down ? xDelta : 0)\n            const sc = down ? 1 - distance / window.innerWidth / 2 : 1\n            return { x, sc, display: 'block' }\n        })\n    })\n\n    return props.map(({ x, display, sc }, i) => (\n            <animated.div {...bind()} key={i} style={{ display, transform: x.interpolate(x => `translate3d(${x}px,0,0)`) }}>\n            <animated.div style={{ transform: sc.interpolate(s => `scale(${s})`), backgroundImage: `url(${pages[i]})` }} />\n            </animated.div>\n    ))\n}\n*/\n\nlet App = () => {\n    const index = useRef(0)\n\n/*\n    const [props, set] = useSprings(pages.length, i => ({ x: i * window.innerWidth, sc: 1, display: 'block' }))\n    const bind = useGesture(({ down, delta: [xDelta], direction: [xDir], distance, cancel }) => {\n        if (down && distance > window.innerWidth / 7)\n            cancel((index.current = clamp(index.current + (xDir > 0 ? -1 : 1), 0, pages.length - 1)))\n        set(i => {\n            if (i < index.current - 1 || i > index.current + 1) return { display: 'none' }\n            const x = (i - index.current) * window.innerWidth + (down ? xDelta : 0)\n            const sc = down ? 1 - distance / window.innerWidth / 2 : 1\n            return { x, sc, display: 'block' }\n        })\n    })\n*/\n\n    const api_root = \"https://comic-editor.s3.eu-north-1.amazonaws.com\"\n    const comic_name = \"One Piece - Digital Colored Comics\"\n\n    //const [comics_json, setComicsJson] = useState(comics_json_LOCAL ? comics_json_LOCAL : null)\n    const [comics_json, setComicsJson] = useState()\n\n    const [comics_labels, setComicsLabels] = useState([])\n    const [comic_data, setComicData] = useState([])\n    const [comic_images, setComicImages] = useState([])\n\n    const [chapter_nr, setChapterNr] = useState(536) //523 ( Add @1 )\n    const [chapter_name, setChapterName] = useState()\n    const [page_nr, setPageNr] = useState(1)\n    const [page_count, setPageCount] = useState(0)\n    const [source_arr, setSourceArr] = useState([])\n\n    const [hq_enabled, setHQEnabled] = useState(false)\n    const [has_hq, setHasHQ] = useState(false)\n    const [preload_images, setPreloadImages] = useState(true)\n\n    const [pages_data, setPagesData] = useState([])\n    const [swiped, setSwiped] = useState(false)\n    const [is_drawer_open, setIsDrawerOpen] = useState(false)\n\n    const [current_label, setCurrentLabel] = useState()\n    const listRef = useRef(null);\n\n    useEffect(() => {fetchComics(comics_json)}, [comics_json]);\n    //useEffect(() => {getComicsLabels(comics_labels)}, [comics_json, comic_name])\n    //useEffect(() => {getComicData(comic_data)}, [comics_json, chapter_nr])\n\n\n    const getComicData = () => {\n        //if(isNaN(comics_json)) return;\n        //let comic_data = comics_json[comic_name]\n    }\n\n    const getComicImages = (new_chapter) => {\n\tif(! preload_images) return;\n\tfor(var i=1;i <= new_chapter.count;i++) {\n\t\tnew Image().src = encodeURI(`${api_root}/${comic_name}/${new_chapter.label}/${new_chapter.hq && hq_enabled?\"hq/\":\"\"}${pad(i)}.png`)\n\t\t//new Image().src = encodeURI(`${api_root}/${comic_name}/${new_chapter.label}/${pad(i)}.png`)\n\t}\n    }\n\n    const getComicsLabels = (json) => {\n        //if(isNaN(json)) return;\n        let labels = [];\n        Object.entries(json[comic_name]).forEach(function(chapter, index) {\n            let title = chapter[1]['t']\n            let count = chapter[1]['c']\n            let hq    = chapter[1]['hq']\n            labels[index] = { value: index, label: title, count: count, hq: hq}\n        })\n        setComicsLabels(labels)\n\tnew Image().src = encodeURI(`${api_root}/${comic_name}/${labels[chapter_nr].label}/${labels[chapter_nr].hq && hq_enabled?\"hq/\":\"\"}${pad(2)}.png`) // Preload the Second Image\n\tchangeChapter(labels, chapter_nr, 1)\n\t//getComicImages(labels[chapter_nr]);\n        //setPage(labels[chapter_nr], 1)\n\t//setPageCount(count)\n    }\n\n    const fetchComics = async () => {\n\tif(comics_json) return;\n\tif(comics_json_LOCAL) {\n\t\tsetComicsJson(comics_json_LOCAL)\n\t\tgetComicsLabels(comics_json_LOCAL)\n\t\treturn;\n\t}\n        try {\n            const response = await fetch(encodeURI(`${api_root}/comics.json`))\n            let json = await response.json()\n            //let labels = []\n            //Object.keys(json).forEach(function(index) {labels[index] = json[index]})\n            setComicsJson(json);\n\t    getComicsLabels(json)\n        } catch(error) {\n            console.error(error)\n        }\n    };\n\n    const handleClick = (event) => {\n\t//console.log(event);\n        if(event.type === \"mouseclick\") {\n            alert(event)\n        }\n    }\n\n    const setPage = (data, nr=null) => {\n\tif(typeof(nr) !== \"number\") nr=1;\n\tconsole.log(data)\n\t//if(data.value !== chapter_nr) {\n\t\t//changeChapter(data.value)\n\n\t\t//return\n\t//}\n        setPageNr(nr)\n\tsetCurrentLabel(data)\n        setSourceArr(encodeURI(`${api_root}/${comic_name}/${data.label}/${data.hq && hq_enabled?\"hq/\":\"\"}${pad(nr)}.png`))\n    }\n\n    const changeChapter = (labels, new_chapter_nr, new_page_nr) => {\n\t//getComicImages(labels[new_chapter_nr])\n        setChapterName(labels[new_chapter_nr].label)\n        setChapterNr(new_chapter_nr)\n        setHasHQ(labels[new_chapter_nr].hq)\n\tsetPage(labels[new_chapter_nr], new_page_nr)\n\tnew Image().src = encodeURI(`${api_root}/${comic_name}/${labels[new_chapter_nr].label}/${labels[new_chapter_nr].hq && hq_enabled?\"hq/\":\"\"}${pad(2)}.png`) // Preload the Second Image\n    }\n\n    const prevChapter = () => {\n\t    changeChapter(comics_labels, chapter_nr-1, comics_labels[chapter_nr-1].count-1)\n    }\n    const nextChapter = () => {\n\t    changeChapter(comics_labels, chapter_nr+1, 1)\n    }\n\n\n    const nextPage = () => {\n\tconsole.log(\"Next Page\")\n\tif(page_nr+1 >= comics_labels[chapter_nr].count) {\n\t\tnextChapter();\n\t\t//changeChapter(comics_labels, chapter_nr+1, 1)\n\t} else {\n\t\tsetPage(comics_labels[chapter_nr], page_nr+1)\n\t}\n\tif(page_nr+1 === 2) {\n\t\tgetComicImages(comics_labels[chapter_nr]) // Preload rest of Images\n\t}\n/*\n\telse\n\tif(page_nr+1 === comics_labels[chapter_nr].count/2) {\n\t\tgetComicImages(comics_labels[chapter_nr+1])\n\t}\n*/\n    }\n    const prevPage = () => {\n\tconsole.log(\"Prev Page\")\n\tif (page_nr-1 <= 0) {\n\t\tprevChapter();\n\t\t//changeChapter(comics_labels, chapter_nr-1, comics_labels[chapter_nr-1].count-1)\n\t} else {\n\t\tsetPage(comics_labels[chapter_nr], page_nr-1)\n\t}\n/*\n\telse\n\tif(page_nr+1 === comics_labels[chapter_nr].count/2) {\n\t\tgetComicImages(comics_labels[chapter_nr-1])\n\t}\n*/\n    }\n    const onTap = (touch) => {\n\t//console.log(touch.clientX)\n\tconst sideMargin = window.innerWidth / 6;\n\tif(touch.clientX < sideMargin) {\n\t\tnextPage();\n\t} else\n\tif(touch.clientX > window.innerWidth - sideMargin) {\n\t\tprevPage();\n\t}\n    }\n\n    /*\n    return props.map(({ x, display, sc }, i) => (\n            <animated.div {...bind()} key={i} style={{ display, transform: x.interpolate(x => `translate3d(${x}px,0,0)`) }}>\n            <animated.div style={{ transform: sc.interpolate(s => `scale(${s})`), backgroundImage: `url(${pages[i]})` }} />\n            </animated.div>\n    ))\n    */\n\n    const handlers = useSwipeable({\n        onSwipedLeft: () => console.warn(\"Alternative swipe Left\"),\n        onSwipedRight: () => console.warn(\"Alternative swipe Right\"),\n        preventDefaultTouchmoveEvent: true,\n        trackMouse: true\n    })\n\n    const listChange = (e) => {\n\t    console.log(e)\n    }\n\n    const drawerChange = (val) => {\n\tsetIsDrawerOpen(val)\n\tconsole.log(listRef.current)\n\t//console.log(listRef.current.scrollToIndex(chapter_nr+24))\n\t//if(val) listRef.current.scrollToIndex(chapter_nr+24)\n    }\n\n    const renderLabel = ({key, index, style}) => {\n\treturn(\n\t\t//<div key={label.key} onClick={() => changeChapter(comics_labels, label.value, 1)}><b>{(label.value === chapter_nr)?'• ':''}{label.value+1}</b></div>\n\t\t<div id=\"list-label\" key={key} style={style} onClick={() => changeChapter(comics_labels, index, 1)}>{(index === chapter_nr)?'• ':' '}{true?\"Chapter: \"+(index+1):comics_labels[index].label}</div>\n\t)\n\t    //return(<li key={label.key} onClick={() => setPage(label)}><b>{label.value}</b></li>)\n    }\n\n    const reloadSource = (label) => {\n        setSourceArr(encodeURI(`${api_root}/${comic_name}/${label.label}/${label.hq && hq_enabled?\"hq/\":\"\"}${pad(page_nr)}.png`))\n    }\n\n    return (\n        <>\n        {comics_labels && false ? <Dropdown options={comics_labels} onChange={setPage} value={comics_labels[chapter_nr]} placeholder=\"Select an option\" /> : null}\n        {\n              //comic_images ? <Dropdown options={comic_images} onChange={setPage} value={comic_images[page_nr]} placeholder=\"Select an option\" /> : null\n        }\n\t<Drawer open={is_drawer_open} onChange={drawerChange}>\n\t<button onClick={() => (setHQEnabled(!hq_enabled) && changeChapter(comics_labels, chapter_nr, 1))}>Toggle HQ</button>\n        {comics_labels && false ? <Flatlist list={comics_labels} onChange={setPage} scrollToInitialIndex={chapter_nr} renderItem={renderLabel} /> : null}\n        {comics_labels && true ?\n\t<AutoSize>\n\t{({width, height}) => (\n<List\n\tref={listRef}\n\t//ref={(elem) => (elem.current.scrollToIndex(chapter_nr+24))}\n\twidth={width}\n\theight={height}\n\trowCount={comics_labels.length}\n\trowHeight={30}\n\trowRenderer={renderLabel}\n\tscrollToIndex={chapter_nr+24}\n\trenderItem={renderLabel}\n/> )}\n</AutoSize>\n\n\n: null}\n\n\t{ comics_labels && false ? comics_labels.map(function(label) {\n\t\t//return <li>i</li>\n    \t\t//const changeChapter = (labels, new_chapter_nr, new_page_nr) => {\n\t\t//return (<li key={label.value} onClick={console.log}>{label.value}</li>)\n\t\treturn (<li key={label.value} data-id={\"Test\"} onClick={listChange.bind(this)}>{label.value}</li>)\n\t}) : null}\n\t</Drawer>\n        {\n            chapter_name ?\n\t\t<EventComponent onSwiped={setSwiped} onSwipedLeft={nextPage} onSwipedRight={prevPage} onTap={onTap}>\n                <div id=\"img-box\" {...tapOrClick(handleClick)}>\n\n{ false ?\n<>\n\t<b>{`${swiped?'Swiped':'Not Swiped'}`}</b>\n\t<b>{`${page_nr}`}</b>\n</>\n: null}\n\t{window.scrollTo(0, 0)}\n\t\t{false ?\n                <ReactImageAppear id=\"img-background\" {...handlers}\n            src={encodeURI(`${api_root}/${comic_name}/${chapter_name}${has_hq && hq_enabled?\"/hq/\":\"/\"}${pad(page_nr)}.png?${new Date().getTime()}`)} placeholder={encodeURI(`${api_root}/${comic_name}/${chapter_name}/${pad(page_nr)}.png`)} showLoader={false} animationDuration={'0'}/>\n:\n                true ? <img\n\t\t id=\"img-background\"\n\t\t alt=\"\"\n\t\tsrc={source_arr} // source_arr\n\t\t//src={\"https://via.placeholder.com/480x640\"}\n\t\t{...handlers} showLoader={false} animationDuration={'0'}/>\n\t\t:\n\t\t<div id=\"img-background\" {...handlers}>\n\t\t\t<ReactImageAppear\n\t\t\tsrc={encodeURI(`${api_root}/${comic_name}/${chapter_name}${has_hq && hq_enabled?\"/hq/\":\"/\"}${pad(page_nr)}.png?${new Date().getTime()}`)}\n\t\t\tplaceholder={source_arr}/>\n\t\t</div>\n}\n</div>\n</EventComponent>\n                        : null\n        }\n            { false ? <button onClick={nextPage}>Next</button> : null}\n\n        </>\n    )\n}\n\n                    //<animated.div style={{ transform: sc.interpolate(s => `scale(${s})`), backgroundImage: `url(${pages[i]})` }} />\nexport default hot(module)(App);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n//serviceWorker.unregister();\n"],"sourceRoot":""}