{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["pad","val","s","String","length","Number","prototype","this","str","pages","App","index","useRef","useSprings","i","x","window","innerWidth","sc","display","set","api_root","useGesture","down","xDelta","delta","xDir","direction","distance","cancel","current","clamp","comic_name","useState","comics_json_LOCAL","comics_json","setComicsJson","comics_labels","setComicsLabels","comic_data","chapter_nr","chapter_name","setChapterName","page_nr","setPageNr","hq_enabled","has_hq","setHasHQ","useEffect","fetchComics","getComicsLabels","getComicData","labels","Object","entries","forEach","chapter","title","hq","value","label","setPage","a","fetch","encodeURI","response","json","keys","console","error","data","handlers","useSwipeable","onSwipedLeft","alert","onSwipedRight","preventDefaultTouchmoveEvent","trackMouse","id","tapOrClick","event","log","type","ReactImageAppear","src","placeholder","showLoader","animationDuration","onClick","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.04b5c176.chunk.js","sourcesContent":["import { render } from 'react-dom'\nimport React, { useEffect, useState, Image, useRef} from 'react';\nimport { hot } from 'react-hot-loader';\nimport Img from 'react-image'\nimport ReactImageAppear from 'react-image-appear'\nimport './App.css';\n\n//import axios from 'axios'\nimport Dropdown from 'react-dropdown'\nimport 'react-dropdown/style.css'\n\n//import { Swipeable, defineSwipe } from 'react-touch'\n\nimport clamp from 'lodash-es/clamp'\nimport { useSprings, animated } from 'react-spring'\nimport { useGesture } from 'react-with-gesture'\n//import './styles.css'\n\nimport tapOrClick from 'react-tap-or-click'\nimport { useSwipeable } from 'react-swipeable'\n\nimport comics_json_LOCAL from './comic.json'\n//var comics_json_LOCAL = NaN\n\n//import { fetchJSON } from './utils/comicUtils.js'\n\ninterface Number {\n    pad: () => string;\n    str: () => string;\n}\n\nfunction pad(val : number) {\n    var s = String(val)\n    const size = 3;\n    while (s.length < (size || 2)) {s = \"0\" + s;}\n    return s;\n}\n\nNumber.prototype.pad = function() : string {\n    var s = String(this);\n    const size = 3;\n    while (s.length < (size || 2)) {s = \"0\" + s;}\n    return s;\n}\n\nNumber.prototype.str = function() : string {\n    return String(this)\n}\n\nconst pages = [\n    'https://images.pexels.com/photos/62689/pexels-photo-62689.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260',\n    'https://images.pexels.com/photos/296878/pexels-photo-296878.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260',\n    'https://images.pexels.com/photos/1509428/pexels-photo-1509428.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260',\n    'https://images.pexels.com/photos/351265/pexels-photo-351265.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260',\n    'https://images.pexels.com/photos/924675/pexels-photo-924675.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260'\n]\n\nlet Viewpager = () => {\n    const index = useRef(0)\n\n    const [props, set] = useSprings(pages.length, i => ({ x: i * window.innerWidth, sc: 1, display: 'block' }))\n\n    const bind = useGesture(({ down, delta: [xDelta], direction: [xDir], distance, cancel }) => {\n        if (down && distance > window.innerWidth / 7)\n            cancel((index.current = clamp(index.current + (xDir > 0 ? -1 : 1), 0, pages.length - 1)))\n        set(i => {\n            if (i < index.current - 1 || i > index.current + 1) return { display: 'none' }\n            const x = (i - index.current) * window.innerWidth + (down ? xDelta : 0)\n            const sc = down ? 1 - distance / window.innerWidth / 2 : 1\n            return { x, sc, display: 'block' }\n        })\n    })\n\n    return props.map(({ x, display, sc }, i) => (\n            <animated.div {...bind()} key={i} style={{ display, transform: x.interpolate(x => `translate3d(${x}px,0,0)`) }}>\n            <animated.div style={{ transform: sc.interpolate(s => `scale(${s})`), backgroundImage: `url(${pages[i]})` }} />\n            </animated.div>\n    ))\n}\n\nlet App = () => {\n\tconst index = useRef(0)\n\n    const [props, set] = useSprings(pages.length, i => ({ x: i * window.innerWidth, sc: 1, display: 'block' }))\n    const bind = useGesture(({ down, delta: [xDelta], direction: [xDir], distance, cancel }) => {\n        if (down && distance > window.innerWidth / 7)\n            cancel((index.current = clamp(index.current + (xDir > 0 ? -1 : 1), 0, pages.length - 1)))\n        set(i => {\n            if (i < index.current - 1 || i > index.current + 1) return { display: 'none' }\n            const x = (i - index.current) * window.innerWidth + (down ? xDelta : 0)\n            const sc = down ? 1 - distance / window.innerWidth / 2 : 1\n            return { x, sc, display: 'block' }\n        })\n    })\n   \n    const api_root = \"https://comic-editor.s3.eu-north-1.amazonaws.com\"\n    const comic_name = \"One Piece - Digital Colored Comics\"\n\n    const [comics_json, setComicsJson] = useState(comics_json_LOCAL)\n    const [comics_labels, setComicsLabels] = useState([])\n    const [comic_data, setComicData] = useState([])\n    const [comic_images, setComicImages] = useState([])\n\n    const [chapter_nr, setChapterNr] = useState(512)\n    const [chapter_name, setChapterName] = useState()\n    const [page_nr, setPageNr] = useState(1)\n\n    const [hq_enabled, setHQEnabled] = useState(false)\n    const [has_hq, setHasHQ] = useState(false)\n\n    const [pages_data, setPagesData] = useState([])\n\n    useEffect(() => {fetchComics(comics_json)}, [comics_json]);\n    useEffect(() => {getComicsLabels(comics_labels)}, [comics_json])\n    //useEffect(() => {getComicImages(comic_images)}, [comics_json, chapter_nr])\n    useEffect(() => {getComicData(comic_data)}, [comics_json, chapter_nr])\n\n    const getComicData = () => {\n        let comic_data = comics_json[comic_name]\n    }\n\n    /*\n    const getComicImages = () => {\n        let images = []\n        images[0] = {index: 0, label: \"Empty\", source: null}\n        setComicImages(images)\n    }*/\n\n    const getComicsLabels = () => {\n        let labels = [];\n        Object.entries(comics_json[comic_name]).forEach(function(chapter, index) {\n            let title = chapter[1]['t']\n            let count = chapter[1]['c']\n            let hq =    (chapter[1]['h'] === \"true\") ? true : false\n\n            labels[index] = { value: index, label: title, hq: hq }\n        })\n        setComicsLabels(labels)\n        setPage(labels[chapter_nr])\n    }\n\n    const fetchComics = async () => {\n        if(comics_json) return;\n        try {\n            const response = await fetch(encodeURI(`${api_root}/${comic_name}/comic.json`))\n            let json = await response.json()\n            let labels = []\n            Object.keys(json).forEach(function(index) {labels[index] = json[index]})\n            setComicsJson(json);\n        } catch(error) {\n            console.error(error)\n        }\n    };\n\n    const handleClick = (event) => {\n\n            console.log(event);\n        if(event.type === \"mouseclick\") {\n            alert(event)\n        }\n    }\n\n    const setPage = (data) => {\n        setPageNr(1)\n        setChapterName(data.label)\n        setHasHQ(data.hq)\n    }\n\n    /*\n    return props.map(({ x, display, sc }, i) => (\n            <animated.div {...bind()} key={i} style={{ display, transform: x.interpolate(x => `translate3d(${x}px,0,0)`) }}>\n            <animated.div style={{ transform: sc.interpolate(s => `scale(${s})`), backgroundImage: `url(${pages[i]})` }} />\n            </animated.div>\n    ))\n    */\n\n    const handlers = useSwipeable({\n        onSwipedLeft: () => alert(2),\n        onSwipedRight: () => alert(1),\n        preventDefaultTouchmoveEvent: true,\n        trackMouse: true\n    })\n\n    return (\n        <div>\n        {comics_labels && false ? <Dropdown options={comics_labels} onChange={setPage} value={comics_labels[chapter_nr]} placeholder=\"Select an option\" /> : null}\n        {\n            /*\n              comic_images ? <Dropdown options={comic_images} onChange={_onSelect} value={comic_images[0]} placeholder=\"Select an option\" /> : null\n            */\n        }\n        {\n            chapter_name ?\n                <div id=\"imgbox\" {...tapOrClick(handleClick)}>\n                <ReactImageAppear id=\"center-fit\" {...handlers} \n            src={encodeURI(`${api_root}/${comic_name}/${chapter_name}${has_hq && hq_enabled?\"/hq/\":\"/\"}${pad(page_nr)}.png`)} placeholder={encodeURI(`${api_root}/${comic_name}/${chapter_name}/${pad(page_nr)}.png`)} showLoader={false} animationDuration={'0'}/>\n\n</div>\n                        : null\n        }\n            <button onClick={alert}>Next</button>\n\n        </div>\n    )\n}\n\n                    //<animated.div style={{ transform: sc.interpolate(s => `scale(${s})`), backgroundImage: `url(${pages[i]})` }} />\nexport default hot(module)(App);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n//serviceWorker.unregister();\n"],"sourceRoot":""}